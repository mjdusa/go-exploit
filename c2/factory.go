package c2

import (
	"github.com/vulncheck-oss/go-exploit/c2/channel"
	"github.com/vulncheck-oss/go-exploit/c2/external"
	"github.com/vulncheck-oss/go-exploit/c2/httpservefile"
	"github.com/vulncheck-oss/go-exploit/c2/httpserveshell"
	"github.com/vulncheck-oss/go-exploit/c2/simpleshell"
	"github.com/vulncheck-oss/go-exploit/c2/sslshell"
	"github.com/vulncheck-oss/go-exploit/output"
)

// A generic interface used by both reverse shells, bind shells, and stagers.
type Interface interface {
	CreateFlags()
	Init(channel channel.Channel) bool
	Run(timeout int)
}

type Impl struct {
	Name     string
	Category impl
}

type impl int

const (
	InvalidImpl           impl = -1
	SimpleShellServerImpl impl = 0
	SimpleShellClientImpl impl = 1
	SSLShellServerImpl    impl = 2
	HTTPServeFileImpl     impl = 3
	HTTPServeShellImpl    impl = 4
	ExternalImpl          impl = 5
)

var (
	SimpleShellServer = internalSupported["SimpleShellServer"]
	SimpleShellClient = internalSupported["SimpleShellClient"]
	SSLShellServer    = internalSupported["SSLShellServer"]
	HTTPServeFile     = internalSupported["HTTPServeFile"]
	HTTPServeShell    = internalSupported["HTTPServeShell"]

	// We do not want this to be called directly because external internally is useless
	externalHandle = internalSupported["External"]
)

var internalSupported = map[string]Impl{
	"SimpleShellServer": {Name: "SimpleShellServer", Category: SimpleShellServerImpl},
	"SimpleShellClient": {Name: "SimpleShellClient", Category: SimpleShellClientImpl},
	"SSLShellServer":    {Name: "SSLShellServer", Category: SSLShellServerImpl},
	"HTTPServeFile":     {Name: "HTTPServeFile", Category: HTTPServeFileImpl},
	"HTTPServeShell":    {Name: "HTTPServeShell", Category: HTTPServeFileImpl},
	// We do not want this to be called directly because external internally is useless
	"External": {Name: "", Category: InvalidImpl},
}

func AddC2(name string) {
	_, exists := internalSupported[name]
	if exists {
		panic("C2 type already exists")
	}

	internalSupported[name] = Impl{Name: name, Category: ExternalImpl}
}

// factory pattern for creating c2 interfaces. Note that this is
// returning an interface, which is a bit anti-Go but it's more or less
// exactly what we want so.
func GetInstance(implementation Impl) (Interface, bool) {
	switch implementation.Category {
	case SimpleShellServerImpl:
		return simpleshell.GetServerInstance(), true
	case SimpleShellClientImpl:
		return simpleshell.GetClientInstance(), true
	case SSLShellServerImpl:
		return sslshell.GetInstance(), true
	case HTTPServeFileImpl:
		return httpservefile.GetInstance(), true
	case HTTPServeShellImpl:
		return httpserveshell.GetInstance(), true
	case ExternalImpl:
		return external.GetInstance(implementation.Name), true
	default:
		output.PrintFrameworkError("Invalid C2 Server")
	}

	return nil, false
}

// call into the c2 impl so that it can create command line flags.
func CreateFlags(implementation Impl) {
	switch implementation.Category {
	case SimpleShellServerImpl:
		simpleshell.GetServerInstance().CreateFlags()
	case SimpleShellClientImpl:
		simpleshell.GetClientInstance().CreateFlags()
	case SSLShellServerImpl:
		sslshell.GetInstance().CreateFlags()
	case HTTPServeFileImpl:
		httpservefile.GetInstance().CreateFlags()
	case HTTPServeShellImpl:
		httpserveshell.GetInstance().CreateFlags()
	case ExternalImpl:
		external.GetInstance(implementation.Name).CreateFlags()
	default:
		output.PrintFrameworkError("Invalid C2 Server")
	}
}

// convert a ServerImpl name to the enum equivalent.
func StringToImpl(c2Name string) (Impl, bool) {
	for _, value := range internalSupported {
		if value.Name == c2Name {
			return value, true
		}
	}

	return Impl{Name: "", Category: InvalidImpl}, false
}
